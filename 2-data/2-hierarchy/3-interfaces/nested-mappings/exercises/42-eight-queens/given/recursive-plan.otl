We can formulate this approach recursively: 

- Assume that we have already generated the sequence of all possible ways to
  place k - 1 queens in the first k - 1 columns of the board. 

- For each of these ways, generate an extended set of positions by placing a
  queen in each row of the kth column. 

- Now filter these, keeping only the positions for which the queen in the kth
  column is safe with respect to the other queens. 

- This produces the sequence of all ways to place k queens in the first k
  columns. By continuing this process, we will produce not only one solution,
  but all solutions to the puzzle.



Case k = 2

	k = 1 solutions:
		(a1)
		(a2)
		(a3)
		. . . 
		(a8)

	for each k - 1 solution:
		generate set of second queen placements
			for (a1)
				(a1 b1)
				(a1 b2)
				(a1 b3)
				. . . 
				(a1 b8)
		filter that set for kth column queen is safe
			(a1 b3)
			. . . 
			(a1 b8)

	set of those solutions is all ways to place k queens
		there will be eight sets, each with a list of positions safe for 2nd queen
		- eg, solutions for that initial placement


Case k = 1

	k = 0 solutions:
		'()

	for each solution:
		generate second set of queen placements
			but, solution set is empty
				need some sort of default ?
				in code, representation?
					<< empty-board >> ?
				or, treat empty set as a solution in its own right
					implies that initial presentation of solutions must be
					list of lists -- '(())

					thus, passes '() to generation

					further implies an implementation detail -- that a
					possible solution will be generated by appending the
					position in the kth column / file to the solution being
					permuted



	
